/*
 *  Hydro-Quebec Dynamic Pricing App
 *  Project URL: https://github.com/NelsonClark/Hubitat/tree/main/Apps/Hydro_Quebec_Dynamic_Pricing
 *  Copyright 2022 Nelson Clark
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 * 
 *  Special thanks to Rachid Aberkan for making a useable API for HQ Events
 *
 *
 *
 *  Versions:
 *
 *  
 *  0.2.0 - 2022/02/06 - First public Beta release
 *  0.1.0 - 2021/12/20 - Initial Beta release private
 *
 */


def setVersion(){
    state.name = "Hydro-Quebec Dynamic Pricing"
    state.version = "0.2.0"
    state.apiUrl = "https://api.didshwa.com/v3/HydroEventCritique"
}


definition(
	name: "Hydro-Quebec Dynamic Pricing",
	namespace: "nclark",
	author: "Nelson Clark",
	description: "Help maximise your return when opted in Hydro Quebec Winter Credit Option and Rate Flex D",
	category: "Green Living",
	iconUrl: "https://raw.githubusercontent.com/NelsonClark/Hubitat/main/Apps/Hydro-Quebec_Dynamic_Pricing/Hydro-Quebec_Dynamic_Pricing-logo-small.png",
	iconX2Url: "https://raw.githubusercontent.com/NelsonClark/Hubitat/main/Apps/Hydro-Quebec_Dynamic_Pricing/Hydro-Quebec_Dynamic_Pricing-logo.png",
)


preferences {
	page(name: "pageConfig")
}


def pageConfig() {
	// Let's just set a few things before starting
    setVersion()
    def displayUnits = getDisplayUnits()
	installed = false
    
    if (!state.deviceID) {
        installed = true
    }
	
    
	dynamicPage(name: "", title: "", install: true, uninstall: true, refreshInterval:0) {
	
        section("<b>$state.name</b> ver. $state.version") {
            input "pauseApp", "bool", title: "Pause App", defaultValue:false, submitOnChange:true
            if(pauseApp) {
                if(app.label) {
                    if(!app.label.contains(" (Paused)")) {
                        app.updateLabel(app.label + " (Paused)")
                    }
                }
            } else {
                if(app.label) {
                    app.updateLabel(app.label - " (Paused)")
                }
            }
            input "testApp", "bool", title: "Test App", defaultValue:false, submitOnChange:true
            if (testApp) {
    		    input "testDate", "string", title: "Date of the next event in format YYYY-MM-DD", required:true, defaultValue:null, submitOnChange:true
    		    input "testStartTime", "string", title: "Start time of the next event in format HH:MM:SS", required:true, defaultValue:null, submitOnChange:true
    		    input "testEndTime", "string", title: "End time of the next event in format HH:MM:SS", required:true, defaultValue:null, submitOnChange:true
            }                
        }

        section(getFormat("header-green", "${getImage("Blank")}"+" Moring and Evening Events")) {}

        section("Morning events...", hideable: true, hidden : true){
		    paragraph "<b>Select outlet(s)/switche(s) to turn off during a morning event.</b>"
		    input "eventMorningSwitches", "capability.switch", title: "Switches", multiple: true
		
            paragraph "<b>Select thermostats to turn <i>OFF</i> during a morning event.</b>"
			input "eventMorningThermostatsOff", "capability.thermostat", title: "Thermostats", multiple: true
            
            paragraph "<b>Select thermostats to turn <i>DOWN</i> during a morning event.</b>"
			input "eventMorningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
		    input "eventMorningDegrees", "number", title: "Number of degrees $displayUnits to drop from current setting", required:true, defaultValue:3
            
            paragraph "<b>Select device to speak to during a morning event.</b>"
            input name: "myDeviceMorning", type: "capability.speechSynthesis", title: "Select speaker"
		    input "morningBeforeText", "string", title: "Text to speak BEFORE morning event", required:false, defaultValue: null
		    input "morningAfterText", "string", title: "Text to speak AFTER morning event", required:false, defaultValue: null           
            
            paragraph "<b>Select devices to increase temperature BEFORE MORNING event</b>"
            input "morningDeviceIncr", "capability.thermostat", title: "Thermostats", multiple: true
		    input "morningHoursIncr", "string", title: "Number of HH:MM to increase temperature BEFORE morning event", required:false, defaultValue: null
		    input "morningTempIncr", "string", title: "Number of degrees to increase temperature BEFORE morning event", required:false, defaultValue: null

        }

        section("Evening events...", hideable: true, hidden : true){
            paragraph "<b>Select outlet(s)/switche(s) to turn off during an evening event.</b>"
			input "eventEveningSwitches", "capability.switch", title: "Switches", multiple: true

		    paragraph "<b>Select thermostats to turn <i>OFF</i> during an evening event.</b>"
			input "eventEveningThermostatsOff", "capability.thermostat", title: "Thermostats", multiple: true

            paragraph "<b>Select thermostats to turn <i>DOWN</i> during an evening event.</b>"
			input "eventEveningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
		    input "eventEveningDegrees", "number", title: "Number of degrees $displayUnits to drop from current setting", required:true, defaultValue:3
            
            paragraph "<b>Select device to speak to during an evening event.</b>"
            input name: "myDeviceEvening", type: "capability.speechSynthesis", title: "Select speaker"
		    input "eveningBeforeText", "string", title: "Text to speak BEFORE evening event", required:false, defaultValue: null
		    input "eveningAfterText", "string", title: "Text to speak AFTER evening event", required:false, defaultValue: null
            
            paragraph "<b>Select devices to increase temperature BEFORE EVENING event</b>"
            input "eveningDeviceIncr", "capability.thermostat", title: "Thermostats", multiple: true
		    input "eveningHoursIncr", "string", title: "Number of HH:MM to increase temperature BEFORE evening event", required:false, defaultValue: null
            input "eveningTempIncr", "string", title: "Number of degrees to increase temperature BEFORE evening event", required:false, defaultValue: null
        }        
        section() {}
        section(getFormat("header-green", "${getImage("Blank")}"+" Settings")) {}

        section (title: "Notifications...", hideable: true, hidden: true) {
		    paragraph "<b>Select switch/light to turn on during MORNING event to indicate event state.</b>"
		    input "morningEventStateSwitch", "capability.switch", title: "Switches", multiple: false
		    paragraph "<b>Select switch/light to turn on during EVENING event to indicate event state.</b>"
		    input "eveningEventStateSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Devices to send notifications to.</b>"
            input "sendPushMessage", "capability.notification", title: "Send a Pushover notification", multiple:true, required:false, submitOnChange:true
            if(sendPushMessage) {
                paragraph "<b>Events to send:</b> Select events to send to the selected notification devices."
                input "startMorningEventPush", "bool", title: "Morning Event Start Report", defaultValue:false, submitOnChange:true, width:6
                input "endMorningEventPush", "bool", title: "Morning Event End Report", defaultValue:false, submitOnChange:true, width:6
                input "startEveningEventPush", "bool", title: "Evening Event Start Report", defaultValue:false, submitOnChange:true, width:6
                input "endEveningEventPush", "bool", title: "Evening Event End Report", defaultValue:false, submitOnChange:true, width:6
                input "newEventsPush", "bool", title: "New Events Added Report", defaultValue:false, submitOnChange:true, width:6
                input "restartEventRecoveryPush", "bool", title: "Restart Event Recovery Report (if enabled)", defaultValue:false, submitOnChange:true, width:6
             }
  		}
        
        section(title: "Advanced Settings...", hideable: true, hidden : true){
		    paragraph "<b>Select switch to poll the API (this can be a virtual winter switch).</b>"
		    input "eventPollEnableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable Morning events (this can be a virtual switch).</b>"
		    input "eventMorningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable Evening events (this can be a virtual switch).</b>"
		    input "eventEveningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select device to speak when a new event is detected.</b>"
            input name: "myDeviceNewEvent", type: "capability.speechSynthesis", title: "Select speaker"
            input "eventDetectedTextAM", "string", title: "Text to speak for morning event", required:false, defaultValue: null
            input "eventDetectedTextPM", "string", title: "Text to speak for evening event", required:false, defaultValue: null

            input "restartEventRecovery", "bool", title: "Hub restart event recovery.", defaultValue:true, submitOnChange:true, width:6

            if (state.testMode) {
                input name: "btnOne", type: "button", title: "Start Morning Event"
                input name: "btnTwo", type: "button", title: "End Morning Event"
                input name: "btnThree", type: "button", title: "Test API Poling"
                input "testJSON1", "bool", title: "Use test JSON tomorrow", defaultValue:false, submitOnChange:true, width:6
                input "testJSON2", "bool", title: "Use test JSON clear", defaultValue:false, submitOnChange:true, width:6
            }
        }

        section(title: "Log Settings...", hideable: true, hidden: true) {
			input (name: "logLevel", type: "enum", title: "Live Logging Level: Messages with this level and higher will be logged", options: [[0: 'Disabled'], [1: 'Error'], [2: 'Warning'], [3: 'Info'], [4: 'Debug'], [5: 'Trace']], defaultValue: 3)
			input "logDropLevelTime", "decimal", title: "Drop down to Info Level Minutes", required: true, defaultValue: 5
		}

	}
}


def installed() {

    state.currentMode = "Normal"
    
    initialize()
}


def updated() {

   	// Log level was set to a higher level than 3, drop level to 3 in x number of minutes
	if (settings.logLevel > 3) {
		logger("trace", "Initialize Log Level drop in $settings.logDropLevelTime minutes")
		runIn(settings.logDropLevelTime.toInteger() * 60, logsDropLevel)
	}

    
    
    initialize() 
}


def initialize() {
    logger("debug", "initialize ${app.label}")

    if(pauseApp) {
        unschedule()
    }
    else {
        // Subscribe to Hub restarts so we can make sure events are dealt with correctly
        subscribe(location, "systemStart", hubRestartHandler)

    // Schedule to start polling every day the API
        currTime = new Date()
        if (currTime >= timeToday("12:30") || testApp) {
            startPolling()
        }
        schedule("59 29 12 ? * * *", startPolling, [overwrite: true])
    }
}


def uninstalled() {
    unsubscribe()
    unschedule()
}


//************************************************************
// hubRestartHandler
//     Schedule polling every 15 minutes until we find new data
//
// Signature(s)
//     hubRestartHandler()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def hubRestartHandler(evt) {
    logger("trace", "hubRestartHandler")
    // Hub has restarted, are there events that we missed and should we do something with it...
    if (!restartEventRecovery) {
        logger("warn", "Hub has restarted but the hub restart checking for events feature is not selected.")
        exit
    } 
    
    logger("warn", "Hub has restarted but the checking events feature has not yet been implemented.")
    

    //Go through all events and see if we are within an event period

    
}


//************************************************************
// startPolling
//     Schedule polling every 15 minutes until we find new data
//
// Signature(s)
//     startPolling()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def startPolling() {
    logger("trace", "startPolling")

    if (!eventPollEnableSwitch?.currentValue("switch") || eventPollEnableSwitch.currentValue("switch") == "on")
        if (testApp)
            poll()
        else {
            poll()
            runEvery1Hour(poll)        
        }
}


//************************************************************
// poll
//     Poll API
//
// Signature(s)
//     poll()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def poll() {
    logger("debug", "poll")
	def requestParams = [ uri: state.apiUrl]
	logger("debug", "Poll Api: $requestParams")
	asynchttpGet("pollHandler", requestParams)
}


//************************************************************
// pollHandler
//     Handle polled data and do what is needed whit it
//
// Signature(s)
//     pollHandler(resp, data)
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def pollHandler(resp, data) {
	logger("trace", "pollHandler")
    if(resp.getStatus() == 200 || resp.getStatus() == 207) {
        logger("debug", "Poll Api Successful")
        
        if (state.apiData == resp.data && !testApp) {
            logger("debug", "API data has not changed, nothing to do")
            
            //Let's see if we are after 21:00, if so let's stop poling, for sure no new data.
            currTime = new Date()
            if (currTime > timeToday("21:00")) {
                unschedule(poll)
            }
            exit
        } else {
            //Let's save new data to state variable and see what to do
            state.apiData = resp.data
            logger("debug", "New API data, let's see what's new")
            unschedule(poll)
            handleHQEvents()            
        }
	} else {
		//Error while poling API, no problem we will poll it again in 15 minutes
        logger("warn", "Poll Api error: did not return data: $resp")
        
	}
}


//************************************************************
// handleHQEvents
//     Handle Hydro Quebec events when they appear in the API
//
// Signature(s)
//     handleHQEvents()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def handleHQEvents() {
    logger("trace", "HandleHQEvents")

    response = parseJson(state.apiData)    
   
    if (testApp && testDate && testStartTime && testEndTime)
        response.data.tomorrow = [["date":testDate,"heureDebut":testStartTime,"heureFin":testEndTime]]
    
    def startWinterPeriod = Date.parse("yyyy-MM-dd'T'HH:mm:ss", response.data.info.dateDebutPeriodeHiver.replace(".000+0000",""))
    def endWinterPeriod = Date.parse("yyyy-MM-dd'T'HH:mm:ss", response.data.info.dateFinPeriodeHiver.replace(".000+0000",""))
    def currDate = new Date()

    //Check to see if we are within the period set by power company
    if (timeOfDayIsBetween(startWinterPeriod, endWinterPeriod, currDate)) {
        logger("debug", "We are within the Winter Period, continue...")
        
        //Are there new events
        if (response.data.tomorrow) {
            newEventsPush = ""
            
            for(eventInfo in response.data.tomorrow) {
                
                //Let's parse event info so we can schedule it, send info to logs or even to a device
                eventStartPeriodISO = "$eventInfo.date" + "T" + "$eventInfo.heureDebut"
                eventStartPeriod = Date.parse("yyyy-MM-dd'T'HH:mm:ss", eventStartPeriodISO)
                if (eventStartPeriod < currDate)
                    break

                eventEndPeriodISO = "$eventInfo.date" + "T" + "$eventInfo.heureFin"
                eventEndPeriod = Date.parse("yyyy-MM-dd'T'HH:mm:ss", eventEndPeriodISO)
                eventDate = eventInfo.date.split('-')
                eventStartTime = eventInfo.heureDebut.split(':')
                eventEndTime = eventInfo.heureFin.split(':')
                
                logger("debug", "$eventStartPeriod to $eventEndPeriod")

                //We now need this info as granular as possible so we can schedule using CRON
                eventYear = eventDate[0]
                eventMonth = eventDate[1]
                eventDay = eventDate[2]
                eventStartHour = eventStartTime[0]
                eventStartMinute = eventStartTime[1]
                eventStartSecond = eventStartTime[2]
                eventEndHour = eventEndTime[0]
                eventEndMinute = eventEndTime[1]
                eventEndSecond = eventEndTime[2]
                
                //Add event info to log and notification text
                if (!newEventsPush) {
                    newEventsPush = "New events added for $eventYear/$eventMonth/$eventDay from "
                } else {
                    newEventsPush = newEventsPush + " & " 
                }

                //Let's program events 
                if (eventStartHour.toInteger() < 12) {
                    schedule("$eventStartSecond $eventStartMinute $eventStartHour $eventDay $eventMonth ? $eventYear", setHouseInMorningEventMode, [overwrite: false])
                    schedule("$eventEndSecond $eventEndMinute $eventEndHour $eventDay $eventMonth ? $eventYear", setHouseInMorningNormalMode, [overwrite: false])
                    newEventsPush = newEventsPush + "$eventStartHour:$eventStartMinute:$eventStartSecond to $eventEndHour:$eventEndMinute:$eventEndSecond"
                    myDeviceNewEvent.speak(eventDetectedTextAM)
        
                    if (morningHoursIncr && morningTempIncr && morningHoursIncr.length == 5) {
						incrHr = morningHoursIncr.substring(0,1)
						incrMin = morningHoursIncr.substring(3,4)

                        if (eventStartMinute >= incrMin) {
                            morningMinIncr = eventStartMinute.toInteger() - incrMin.toInteger()
                        }
                        else 
							if (eventStartHour > 0) {
								morningMinIncr = 60 - incrMin.toInteger() + eventStartMinute.toInteger()
								eventStartHour = eventStartHour - 1
							}
							else
								morningMinIncr = 0


                        if (eventStartHour >= morningHoursIncr) {
                            morningHrIncr = eventStartHour.toInteger() - morningHoursIncr.toInteger()
                        }
                        else {
                            morningHrIncr = 0
                        }
                        
                        schedule("$eventStartSecond $morningMinIncr $morningHrIncr $eventDay $eventMonth ? $eventYear", setHouseBeforeMorning, [overwrite: false])
                    }
                } 
                else {
                    schedule("$eventStartSecond $eventStartMinute $eventStartHour $eventDay $eventMonth ? $eventYear", setHouseInEveningEventMode, [overwrite: false])
                    schedule("$eventEndSecond $eventEndMinute $eventEndHour $eventDay $eventMonth ? $eventYear", setHouseInEveningNormalMode, [overwrite: false])
                    newEventsPush = newEventsPush + "$eventStartHour:$eventStartMinute:$eventStartSecond to $eventEndHour:$eventEndMinute:$eventEndSecond"
                    myDeviceNewEvent.speak(eventDetectedTextPM)

                    if (eveningHoursIncr && eveningTempIncr && eveningHoursIncr.length == 5) {
						incrHr = eveningHoursIncr.substring(0,2)
						incrMin = eveningHoursIncr.substring(3,5)

                        if (eventStartMinute >= incrMin) {
                            eveningMinIncr = eventStartMinute.toInteger() - incrMin.toInteger()
                        }
                        else 
							if (eventStartHour > 0) {
								eveningMinIncr = 60 - incrMin.toInteger() + eventStartMinute.toInteger()
								eventStartHour = eventStartHour - 1
							}
							else
								eveningMinIncr = 0

                        if (eventStartHour >= eveningHoursIncr) {
                            eveningHrIncr = eventStartHour.toInteger() - incrHr.toInteger()
                        }
                        else {
                            eveningHrIncr = 0
                        }
                        
                        schedule("$eventStartSecond $eveningMinIncr $eveningHrIncr $eventDay $eventMonth ? $eventYear", setHouseBeforeEvening, [overwrite: false])
                    }
                }
            
                //Send and log info if required
                if(sendPushMessage && newEventsPush) {
                    sendPushMessage.deviceNotification(newEventsPush)
                    logger("debug", newEventsPush)
                }
                else {
                    logger("debug", "No new events.")
                }
            }
        }
    }        
}

//************************************************************
// setHouseBeforeMorning
//     Set the different thermostats BEFORE morning mode
//
// Signature(s)
//     setHouseBeforeMorning()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseBeforeMorning() {
    logger("trace", "setHouseBeforeMorning")

    if (eventMorningDisableSwitch) {
        exit
    }

    def previousSettings = [:]
    for(thermostat in morningDeviceIncr) {
        previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
        newSetpoint = thermostat.currentValue("heatingSetpoint") + morningTempIncr.toInteger()
        thermostat.setHeatingSetpoint(newSetpoint)
        pauseExecution(1000)
    }
}

//************************************************************
// setHouseBeforeEvening
//     Set the different thermostats BEFORE evening mode
//
// Signature(s)
//     setHouseBeforeEvening()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseBeforeEvening() {
    logger("trace", "setHouseBeforeEvening")

    if (eventEveningDisableSwitch) {
        exit
    }

    def previousSettings = [:]
    for(thermostat in eveningDeviceIncr) {
        previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
        newSetpoint = thermostat.currentValue("heatingSetpoint") + eveningTempIncr.toInteger()
        thermostat.setHeatingSetpoint(newSetpoint)
        pauseExecution(1000)
    }
}

//************************************************************
// setHouseInMorningEventMode
//     Set the different outlets, thermostats, etc for morning mode
//
// Signature(s)
//     setHouseInMorningEventMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInMorningEventMode() {
    logger("trace", "setHouseInMorningEventMode")
    
    if (eventMorningDisableSwitch) {
        logger("warn", "Morning event disable activated, skipping this event!")
        exit
    }

    state.currentMode = "MorningEvent"
    if (morningEventStateSwitch)
        morningEventStateSwitch.on()
    
    myDeviceMorning.speak(morningBeforeText)
    
    if(sendPushMessage && startMorningEventPush) {
        sendPushMessage.deviceNotification("Morning event fired!")
    }
    
    def previousSettings = [:]
    
    for(eventSwitch in eventMorningSwitches) {
        previousSettings.put("$eventSwitch",eventSwitch.currentValue("switch"))
        eventSwitch.off()
        pauseExecution(1000)
    }

    for(thermostat in eventMorningThermostatsOff) {
        previousSettings.put("$thermostat",thermostat.currentValue("thermostatMode"))
        if (thermostat.currentValue("thermostatMode") == "off") {      
            logger("debug", "$thermostat already off")
        } else {
            thermostat.setThermostatMode("off")
            pauseExecution(1000)
            logger("debug", "$thermostat turned off")
        }
    }

    // Set back the thermostats that were increased before the event
    if (morningTempIncr) {
        for(thermostat in morningDeviceIncr) {
            previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
            newSetpoint = thermostat.currentValue("heatingSetpoint") - morningTempIncr.toInteger()
            thermostat.setHeatingSetpoint(newSetpoint)
            pauseExecution(1000)
        }
    }
    
    for(thermostat in eventMorningThermostats) {
        previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
        newSetpoint = thermostat.currentValue("heatingSetpoint") - eventEveningDegrees.toInteger()
        thermostat.setHeatingSetpoint(newSetpoint)
        pauseExecution(1000)
    }
    
    state.previousSettings = previousSettings

    app.updateLabel("Hydro Quebec Dynamic Pricing <span style='color:green'>Morning Event in progress</span>")

}


//************************************************************
// setHouseInEveningEventMode
//     Set the different outlets, thermostats, etc for evening mode
//
// Signature(s)
//     setHouseInEveningEventMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInEveningEventMode() {
    logger("trace", "setHouseInEveningEventMode")

    if (eventEveningDisableSwitch) {
        logger("warn", "Evening event disable activated, skipping this event!")
        exit
    }

    state.currentMode = "EveningEvent"
    if (eveningEventStateSwitch)
        eveningEventStateSwitch.on()

    myDeviceEvening.speak(eveningBeforeText)

    if(sendPushMessage && StartEveningEventPush) {
        sendPushMessage.deviceNotification("Evening event fired!")
    }
    
    def previousSettings = [:]
    
    for(eventSwitch in eventEveningSwitches) {
        previousSettings.put("$eventSwitch",eventSwitch.currentValue("switch"))
        eventSwitch.off()
        pauseExecution(1000)
    }

    for(thermostat in eventEveningThermostatsOff) {
        previousSettings.put("$thermostat",thermostat.currentValue("thermostatMode"))
        if (thermostat.currentValue("thermostatMode") == "off") {      
            logger("debug", "$thermostat already off")
        } else {
            thermostat.setThermostatMode("off")
            pauseExecution(1000)
            logger("debug", "$thermostat turned off")
        }
    }

    // Set back the thermostats that were increased before the event
    if (eveningTempIncr) {
        for(thermostat in eveningDeviceIncr) {
            previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
            newSetpoint = thermostat.currentValue("heatingSetpoint") - eveningTempIncr.toInteger()
            thermostat.setHeatingSetpoint(newSetpoint)
            pauseExecution(1000)
        }
    }

    for(thermostat in eventEveningThermostats) {
        previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
        newSetpoint = thermostat.currentValue("heatingSetpoint") - eventEveningDegrees.toInteger()
        thermostat.setHeatingSetpoint(newSetpoint)
        pauseExecution(1000)
    }

    state.previousSettings = previousSettings

    app.updateLabel("Hydro Quebec Dynamic Pricing <span style='color:green'>Evening Event in progress</span>")

}


//************************************************************
// setHouseInMorningNormalMode
//     Set the different outlets, thermostats, etc for normal mode
//
// Signature(s)
//     setHouseInMorningNormalMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInMorningNormalMode() {
    logger("trace", "setHouseInMorningNormalMode")
    
    if (eventMorningDisableSwitch) {
        exit
    }

    state.currentMode = "Normal"
    if (morningEventStateSwitch)
        morningEventStateSwitch.off()
    
    myDeviceMorning.speak(morningAfterText)

    if(sendPushMessage && endMorningEventPush) {
        sendPushMessage.deviceNotification("Back to normal!")
    }
    
    for(eventSwitch in eventMorningSwitches) {
        def switchState = state.previousSettings.find{ it.key == "$eventSwitch" }?.value
        if(switchState && switchState == "on") {
            logger("debug", "$eventSwitch turned $switchState")
            eventSwitch.on()
            pauseExecution(1000)
        } else {
            logger("debug", "$eventSwitch not changed")
        }
    }

    for(thermostat in eventMorningThermostatsOff) {
        def thermostatMode = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatMode) {
            thermostat.setThermostatMode("$thermostatMode")
            logger("debug", "$thermostat mode set to $thermostatMode")
            pauseExecution(1000)
        }
    }

    for(thermostat in eventMorningThermostats) {
        def thermostatTemp = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatTemp) {
            thermostat.setHeatingSetpoint(thermostatTemp)
            logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
            pauseExecution(1000)
        }
    }
    
    state.remove("previousSettings")
    app.updateLabel("Hydro Quebec Dynamic Pricing")
    
}


//************************************************************
// setHouseInEveningNormalMode
//     Set the different outlets, thermostats, etc for normal mode
//
// Signature(s)
//     setHouseInEveningNormalMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInEveningNormalMode() {
    logger("trace", "setHouseInEveningNormalMode")

    if (eventEveningDisableSwitch) {
        exit
    }

    state.currentMode = "Normal"
    if (eveningEventStateSwitch)
        eveningEventStateSwitch.off()

    myDeviceEvening.speak(eveningAfterText)

    if(sendPushMessage && endEveningEventPush) {
        sendPushMessage.deviceNotification("Back to normal!")
    }

    for(eventSwitch in eventEveningSwitches) {
        def switchState = state.previousSettings.find{ it.key == "$eventSwitch" }?.value
        if(switchState && switchState == "on") {
            logger("debug", "$eventSwitch turned $switchState")
            eventSwitch.on()
        } else {
            logger("debug", "$eventSwitch not changed")
        }
    }

    for(thermostat in eventEveningThermostatsOff) {
         def thermostatMode = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatMode) {
            thermostat.setThermostatMode("$thermostatMode")
            logger("debug", "$thermostat mode set to $thermostatMode")
            pauseExecution(1000)
        }
   }

    for(thermostat in eventEveningThermostats) {
        def thermostatTemp = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatTemp) {
            thermostat.setHeatingSetpoint(thermostatTemp)
            logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
            pauseExecution(1000)
        }
    }

    state.remove("previousSettings")
    app.updateLabel("Hydro Quebec Dynamic Pricing")

}


//************************************************************
// logger
//     Wrapper function for all logging with level control via preferences
//
// Signature(s)
//     logger(String level, String msg)
//
// Parameters
//     level : Error level string
//     msg : Message to log
//
// Returns
//     None
//
//************************************************************
def logger(level, msg) {

	switch(level) {
		case "error":
			if (settings.logLevel in ["1", "2", "3", "4", "5"]) log.error msg
			break

		case "warn":
			if (settings.logLevel in ["2", "3", "4", "5"]) log.warn msg
			break

		case "info":
			if (settings.logLevel in ["3", "4", "5"]) log.info msg
			break

		case "debug":
			if (settings.logLevel in ["4", "5"]) log.debug msg
			break

		case "trace":
			if (settings.logLevel in ["5"]) log.trace msg
			break

		default:
			log.debug msg
			break
	}
}


//************************************************************
// logsDropLevel
//     Turn down logLevel to 3 in this app/device and log the change
//
// Signature(s)
//     logsDropLevel()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def logsDropLevel() {
    app.updateSetting("logLevel", [type: "enum", value: "3"])
	logger("warn","Logging level set to 3")
}


//************************************************************
// getDisplayUnits
//     Get the diplay units
// Signature(s)
//     getDisplayUnits()
// Parameters
//     None
// Returns
//     Formated Units String
//************************************************************
def getDisplayUnits() {
	if (getTemperatureScale() == "C") {
		return "°C"
	} else {
		return "°F"
	}
}


//************************************************************
// getFormat
//     Get the fornat for headers
// Signature(s)
//     getFormat(String type, String myText)
// Parameters
//     type: format
//     myTest: Text to diplay
// Returns
//     None
//************************************************************
def getFormat(type, myText="") {			// Modified from @Stephack Code   
	if(type == "header-green") return "<div style='color:#ffffff;font-weight: bold;background-color:#81BC00;border: 1px solid;box-shadow: 2px 3px #A9A9A9'>${myText}</div>"
    if(type == "line") return "<hr style='background-color:#1A77C9; height: 1px; border: 0;'>"
    if(type == "title") return "<h2 style='color:#1A77C9;font-weight: bold'>${myText}</h2>"
}

//************************************************************
// getImage
//     Get the image for headers
// Signature(s)
//     getImage(String type)
// Parameters
//     type: Image
// Returns
//     None
//************************************************************
def getImage(type) {					// Modified from @Stephack Code
    def loc = "<img src=https://raw.githubusercontent.com/jbilodea/HydroQuebec/main/Images/"
    if(type == "Blank") return "${loc}blank.png height=40 width=5}>"
    if(type == "checkMarkGreen") return "${loc}checkMarkGreen2.png height=30 width=30>"
    if(type == "optionsGreen") return "${loc}options-green.png height=30 width=30>"
    if(type == "optionsRed") return "${loc}options-red.png height=30 width=30>"
    if(type == "instructions") return "${loc}instructions.png height=30 width=30>"
    if(type == "logo") return "${loc}logo.png height=60>"
}

//************************************************************
// appButtonHandler
//     Handle menu button events 
// Signature(s)
//     appButtonHandler(string buttonName)
// Parameters
//     None
// Returns
//     None
//************************************************************
void appButtonHandler(String btn) {
   switch (btn) {
      case 'btnOne':
         logger("info", "Button one pressed")
         setHouseInMorningEventMode()
         break
      case 'btnTwo':
         logger("info", "Button two pressed")
         setHouseInMorningNormalMode()
         break
      case 'btnThree':
         logger("info", "Button three pressed")
         poll()
         break
      default:
         logger("warn","Button not handled")
   }
}


//************************************************************
// *** Hiden menu handlers ***
// Parameters
//     None
// Returns
//     Boolean
//************************************************************
private hideAdvancedSection() {(isInfo || isDebug || isTrace || ifLevel) ? false : true}
private hideLogSection() {(logLevel || logDropLevelTime) ? false : true}
private hideNotificationSection() {(sendPushMessage || startMorningEventPush || endMorningEventPush || startEveningEventPush || endEveningEventPush || newEventsPush || restartEventRecoveryPush) ? false : true}
