/*  Hydro-Quebec Dynamic Pricing App
 *  Project URL: https://github.com/NelsonClark/Hubitat/tree/main/Apps/Hydro_Quebec_Dynamic_Pricing
 *  Copyright 2022 Nelson Clark
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 * 
 *  Special thanks to Rachid Aberkan for making a useable API for HQ Events
 *
 *
 *
 *  Versions:
 *
 *  
 *  0.2.0 - 2022/02/06 - First public Beta release
 *  0.1.0 - 2021/12/20 - Initial Beta release private
 *
 */
import java.time.LocalDate
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.text.SimpleDateFormat
import groovy.time.TimeCategory


def setVersion(){
    state.name = "Hydro-Quebec Dynamic Pricing"
    state.version = "1.0.0"
//    state.apiUrl1 = "https://hydro-event.apis.gcp.aberkan.net/creditPointeCritique"    
//    state.apiUrl2 = "https://donnees.hydroquebec.com/api/explore/v2.1/catalog/datasets/evenements-pointe/records?where=offre%3D%22CPC-D%22&order_by=datedebut%20desc&limit=100&timezone=America%2FMontreal"
	state.HQEventURL = "https://donnees.solutions.hydroquebec.com/donnees-ouvertes/data/json/pointeshivernales.json"
	//This is for testing purposes, for normal operation must be set to false
	state.testMode = false
}

definition(
	name: "Hydro-Quebec Dynamic Pricing",
	namespace: "nclark",
	author: "Nelson Clark",
	description: "Help maximise your return when opted in Hydro Quebec Winter Credit Options",
	category: "Green Living",
	iconUrl: "",
	iconX2Url: "",
)


preferences {
	page(name: "pageConfig")
}


def pageConfig() {
	// Let's just set a few things before starting
    setVersion()
    def displayUnits = getDisplayUnits()
	installed = false
    
    if (!state.deviceID) {
        installed = true
    }
	
    
	dynamicPage(name: "", title: "", install: true, uninstall: true, refreshInterval:0) {

		// Event Options with French descriptions (For future version with language preferences)
		/*
		List<Map<String,String>> eventTypeOptions = [
		["CPC-D": "Crédit pointe critique pour le tarif D / Option de crédit hivernal pour la clientèle résidentielle et agricole"],
		["TPC-DPC": "Tarification pointe critique pour le tarif D / Tarif Flex D pour la clientèle résidentielle et agricole"],
		["GDP-Affaires": "Tarification pointe critique pour les tarifs DP, DM, G, G9, M, LG ou H / Option de gestion de la demande de puissance (GDP) pour la clientèle d’affaires"],
		["CPC-G": "Crédit pointe critique pour le tarif G / Option de crédit hivernal pour la clientèle d’affaires de petite puissance"],
		["TPC-GPC": "Tarification pointe critique pour le tarif G / Tarif Flex G pour la clientèle d’affaires"],
		["TPC-M": "Tarif pointe critique pour les tarifs M, LG et G9 / Option d’électricité interruptible pour la clientèle d’affaires de moyenne puissance"],
		["TPC-L-Centre-C2": "Tarif pointe critique pour le tarif L destiné aux secteurs Centre C2 / Option d’électricité interruptible pour la clientèle d’affaires de grande puissance"],
		["TPC-L-Centre-U": "Tarif pointe critique pour le tarif L destiné aux secteurs Centre U / Option d’électricité interruptible pour la clientèle d’affaires de grande puissance"],
		["TPC-L-Sud-D1": "Tarif pointe critique pour le tarif L destiné aux secteurs Sud D1 / Option d’électricité interruptible pour la clientèle d’affaires de grande puissance"],
		["TPC-L-Sud-D2": "Tarif pointe critique pour le tarif L destiné aux secteurs Sud D2 / Option d’électricité interruptible pour la clientèle d’affaires de grande puissance"],
		["OEA": "Option d’électricité additionnelle pour la clientèle de moyenne puissance pour les tarifs M et G9 / grande puissance pour les tarifs L et LG"]
		]
		*/

		// Event Options with English Descriptions
		List<Map<String,String>> eventTypeOptions = [
		["CPC-D": "Critical peak credit for Rate D / Winter Credit Option for residential customers"],
		["TPC-DPC": " Critical peak rate for Rate D / Rate Flex D for residential customers"],
		["GDP-Affaires": "Critical peak rate for rates DP, DM, G, G9, M, LG or H / Demand Response Option for business customers"],
		["CPC-G": "Critical peak credit for rate G / Winter Credit Option for business customers"],
		["TPC-GPC": "Critical peak rate for rates G / Rate Flex G for business customers"],
		["TPC-M": "Critical peak rate for rates M, LG and G9 / Interruptible Electricity Options for medium-power business customers"],
		["TPC-L-Centre-C2": "Critical peak Rate L in sectors Centre C2 / Interruptible Electricity Options for large-power business customers"],
		["TPC-L-Centre-U": "Critical peak Rate L in sectors Centre U / Interruptible Electricity Options for large-power business customers"],
		["TPC-L-Sud-D1": "Critical peak Rate L in sectors Sud D1 / Interruptible Electricity Options for large-power business customers"],
		["TPC-L-Sud-D2": "Critical peak Rate L in sectors Sud D2 / Interruptible Electricity Options for large-power business customers"],
		["OEA": "Additional Electricity Options for medium-power business customers of rates M and G9 / large-power business customers of rates L and LG"]
		]        
        
        section("<b>$state.name</b> ver. $state.version") {
            input "pauseApp", "bool", title: "Pause App/ Clear Schedules", defaultValue:false, submitOnChange:true
            if(pauseApp) {
                if(app.label) {
                    if(!app.label.contains(" (Paused)")) {
                        app.updateLabel(app.label + " (Paused)")
                    }
                }
            } else {
                if(app.label) {
                    app.updateLabel(app.label - " (Paused)")
                }
            }
			input "clearEvents", "bool", title: "Clear all data (Events and States)", defaultValue:false, submitOnChange:true
            input "pollEvery15Mins", "bool", title: "Start Polling every 15 minutes", defaultValue:false, submitOnChange:true
            if(pollEvery15Mins) {
                unschedule(poll)
                poll()
                runEvery15Minutes(poll)
            }
            else {
        		currTime = new Date()
        		if (currTime < timeToday("11:30")) {
            		unschedule(poll)
                }
        	}            
            input "testApp", "bool", title: "Test App", defaultValue:false, submitOnChange:true
            if (testApp) {
    		    input "testDate", "string", title: "Date of the next event in format YYYY-MM-DD", required:true, defaultValue:null, submitOnChange:true
    		    input "testStartTime", "string", title: "Start time of the next event in format HH:MM:SS", required:true, defaultValue:null, submitOnChange:true
    		    input "testEndTime", "string", title: "End time of the next event in format HH:MM:SS", required:true, defaultValue:null, submitOnChange:true
            }                
        }

        section(getFormat("header-green", "${getImage("Blank")}"+" Moring and Evening Events")) {}

		section(title: "Event types and Polling...", hideable: true, hidden: hideEventTypeSection()) {
			input (name: "eventType", type: "enum", title: "<br><b>Hydro Quebec Event types you are Subscribed to</b>", options: eventTypeOptions, required: true, defaultValue: "CPC-D")

			paragraph "<br>"
			input (name: "pollStartTime", type: "time", title: "<br><b>Time to start poling the API <i>Around 13:00 is a good time</i></b>", defaultValue: "13:13")
        }
        section("Morning events...", hideable: true, hidden : true){
		    paragraph "<b>Select outlet(s)/switche(s) to turn off during a morning event.</b>"
		    input "eventMorningSwitches", "capability.switch", title: "Switches", multiple: true
		
            paragraph "<b>Select thermostats to turn <i>OFF</i> during a morning event.</b>"
			input "eventMorningThermostatsOff", "capability.thermostat", title: "Thermostats", multiple: true
            
            paragraph "<b>Select thermostats to turn <i>DOWN</i> during a morning event.</b>"
			input "eventMorningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
		    input "eventMorningDegrees", "number", title: "Number of degrees $displayUnits to drop from current setting", required:true, defaultValue:3
            
            paragraph "<b>Select device to speak to during a morning event.</b>"
            input name: "myDeviceMorning", type: "capability.speechSynthesis", title: "Select speaker"
		    input "morningBeforeText", "string", title: "Text to speak BEFORE morning event", required:false, defaultValue: null
		    input "morningAfterText", "string", title: "Text to speak AFTER morning event", required:false, defaultValue: null           
            
            paragraph "<b>Select devices to increase temperature BEFORE MORNING event</b>"
            input "preEventMorningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
			input "preEventMorningMinutes", "number", title: "Number of minutes before MORNING event (1 to disable)", required:true, defaultValue:120, submitOnChange:true
		    input "preEventMorningDegrees", "string", title: "Number of degrees to increase temperature BEFORE morning event", required:false, defaultValue: null

        }

        section("Evening events...", hideable: true, hidden : true){
            paragraph "<b>Select outlet(s)/switche(s) to turn off during an evening event.</b>"
			input "eventEveningSwitches", "capability.switch", title: "Switches", multiple: true

		    paragraph "<b>Select thermostats to turn <i>OFF</i> during an evening event.</b>"
			input "eventEveningThermostatsOff", "capability.thermostat", title: "Thermostats", multiple: true

            paragraph "<b>Select thermostats to turn <i>DOWN</i> during an evening event.</b>"
			input "eventEveningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
		    input "eventEveningDegrees", "number", title: "Number of degrees $displayUnits to drop from current setting", required:true, defaultValue:3
            
            paragraph "<b>Select device to speak to during an evening event.</b>"
            input name: "myDeviceEvening", type: "capability.speechSynthesis", title: "Select speaker"
		    input "eveningBeforeText", "string", title: "Text to speak BEFORE evening event", required:false, defaultValue: null
		    input "eveningAfterText", "string", title: "Text to speak AFTER evening event", required:false, defaultValue: null
            
            paragraph "<b>Select devices to increase temperature BEFORE EVENING event</b>"
            input "preEventEveningThermostats", "capability.thermostat", title: "Thermostats", multiple: true
			input "preEventEveningMinutes", "number", title: "Number of minutes before EVENING event (1 to disable)", required:true, defaultValue:120, submitOnChange:true
            input "preEventEveningDegrees", "string", title: "Number of degrees to increase temperature BEFORE evening event", required:false, defaultValue: null
        }        
        section() {}
        section(getFormat("header-green", "${getImage("Blank")}"+" Settings")) {}

        section (title: "Notifications...", hideable: true, hidden: true) {
		    paragraph "<b>Select switch/light to turn on during MORNING event to indicate event state.</b>"
		    input "morningEventStateSwitch", "capability.switch", title: "Switches", multiple: false
		    paragraph "<b>Select switch/light to turn on during EVENING event to indicate event state.</b>"
		    input "eveningEventStateSwitch", "capability.switch", title: "Switches", multiple: false

		    paragraph "<b>Select switch to turn when an event is detected for the TOMORROW'S MORNING.</b>"
		    input "tomorrowMorningEventStateSwitch", "capability.switch", title: "Switches", multiple: false
		    paragraph "<b>Select switch to turn when an event is detected for the TOMORROW'S EVENING.</b>"
		    input "tomorrowEveningEventStateSwitch", "capability.switch", title: "Switches", multiple: false
            
            paragraph "<b>Devices to send notifications to.</b>"
            input "sendPushMessage", "capability.notification", title: "Send a Pushover notification", multiple:true, required:false, submitOnChange:true
            if(sendPushMessage) {
                paragraph "<b>Events to send:</b> Select events to send to the selected notification devices."
				input "startMorningPreEventPush", "bool", title: "Morning Pre-Event Start Report", defaultValue:false, submitOnChange:true, width:6
				input "startEveningPreEventPush", "bool", title: "Evening Pre-Event Start Report", defaultValue:false, submitOnChange:true, width:6
                input "startMorningEventPush", "bool", title: "Morning Event Start Report", defaultValue:false, submitOnChange:true, width:6
                input "endMorningEventPush", "bool", title: "Morning Event End Report", defaultValue:false, submitOnChange:true, width:6
                input "startEveningEventPush", "bool", title: "Evening Event Start Report", defaultValue:false, submitOnChange:true, width:6
                input "endEveningEventPush", "bool", title: "Evening Event End Report", defaultValue:false, submitOnChange:true, width:6
                input "newEventsPush", "bool", title: "New Events Added Report", defaultValue:false, submitOnChange:true, width:6
                input "restartEventRecoveryPush", "bool", title: "Restart Event Recovery Report (if enabled)", defaultValue:false, submitOnChange:true, width:6
             }
  		}
        
        section(title: "Advanced Settings...", hideable: true, hidden : true){
		    paragraph "<b>Select switch to poll the API (this can be a virtual winter switch).</b>"
		    input "eventPollEnableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable BEFORE Morning events (this can be a virtual switch).</b>"
		    input "eventMorningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable Morning events (this can be a virtual switch).</b>"
		    input "eventMorningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable BEFORE Evening events (this can be a virtual switch).</b>"
		    input "eventBeforeEveningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select switch to disable Evening events (this can be a virtual switch).</b>"
		    input "eventEveningDisableSwitch", "capability.switch", title: "Switches", multiple: false

            paragraph "<b>Select device to speak when a new event is detected.</b>"
            input name: "myDeviceNewEvent", type: "capability.speechSynthesis", title: "Select speaker"
            input "eventDetectedTextAM", "string", title: "Text to speak for morning event", required:false, defaultValue: null
            input "eventDetectedTextPM", "string", title: "Text to speak for evening event", required:false, defaultValue: null

            input "restartEventRecovery", "bool", title: "Hub restart event recovery.", defaultValue:true, submitOnChange:true, width:6

            if (state.testMode) {
                input name: "btnOne", type: "button", title: "Start Morning Event"
                input name: "btnTwo", type: "button", title: "End Morning Event"
                input name: "btnThree", type: "button", title: "Test API Poling"
                input "testJSON1", "bool", title: "Use test JSON tomorrow", defaultValue:false, submitOnChange:true, width:6
                input "testJSON2", "bool", title: "Use test JSON clear", defaultValue:false, submitOnChange:true, width:6
            }
        }

        section(title: "Log Settings...", hideable: true, hidden: true) {
			input (name: "logLevel", type: "enum", title: "Live Logging Level: Messages with this level and higher will be logged", options: [[0: 'Disabled'], [1: 'Error'], [2: 'Warning'], [3: 'Info'], [4: 'Debug'], [5: 'Trace']], defaultValue: 3)
			input "logDropLevelTime", "decimal", title: "Drop down to Info Level Minutes", required: true, defaultValue: 5
		}
		
	}
}


def installed() {

    state.currentMode = "Normal"
    
    initialize()
	poll()
}


def updated() {

   	// Log level was set to a higher level than 3, drop level to 3 in x number of minutes
	if (settings.logLevel > 3) {
		logger("trace", "Initialize Log Level drop in $settings.logDropLevelTime minutes")
		runIn(settings.logDropLevelTime.toInteger() * 60, logsDropLevel)
	}

    initialize() 
}


def initialize() {
    logger("debug", "initialize ${app.label}")

//state.remove("tomorrowMorningEvent")        
//unschedule(setHouseInEveningNormalMode)

    // Subscribe to Hub restarts so we can make sure events are dealt with correctly
    subscribe(location, "systemStart", hubRestartHandler)

    if (clearEvents) {
        state.apiData = ""
		tomorrowMorningEventStateSwitch.off()      
        tomorrowEveningEventStateSwitch.off()
        app.updateSetting("clearEvents", [value: false, type: "bool"])
        unschedule()
    }
    else {    
    	if(pauseApp) {
        	unschedule()
	    }        
    	else {
    	// Schedule to start polling every day the API
			if (!pollStartTime) {
				if (currTime >= timeToday("11:30") || testApp) {
					startPolling()
				}
				schedule("00 30 11 ? * * *", startPolling, [overwrite: true])
			} else {
				currTime = new Date()
	        	if (currTime >= timeToday(pollStartTime) || testApp) {
					startPolling()
				}
				schedule(pollStartTime, startPolling, [overwrite: true])
			}
        }
    }
}

def uninstalled() {
    unsubscribe()
    unschedule()
}

//************************************************************
// hubRestartHandler
//     Schedule polling every 15 minutes until we find new data
//
// Signature(s)
//     hubRestartHandler()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def hubRestartHandler(evt) {
    logger("trace", "hubRestartHandler")
    // Hub has restarted, are there events that we missed and should we do something with it...
    if (!restartEventRecovery) {
        logger("warn", "Hub has restarted but the hub restart checking for events feature is not selected.")
        exit
    } 
    
    logger("warn", "Hub has restarted but the checking events feature has not yet been implemented.")
    
	//Remove all events, poll API and schedule all upcoming events
	state.pollManually = true
	unschedule("setHouseInMorningPreEventMode")
	unschedule("setHouseInMorningEventMode")
	unschedule("setHouseInMorningNormalMode")
	unschedule("setHouseInEveningPreEventMode")
	unschedule("setHouseInEveningEventMode")
	unschedule("setHouseInEveningNormalMode")
	
	poll()

	logger("trace","---End hubRestartHandler")
    
}


//************************************************************
// startPolling
//     Schedule polling every 15 minutes until we find new data
//
// Signature(s)
//     startPolling()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def startPolling() {
    logger("trace", "startPolling")

    if (!eventPollEnableSwitch?.currentValue("switch") || eventPollEnableSwitch.currentValue("switch") == "on") {
        poll()
        if (!testApp) {
            unschedule(poll)
            runEvery15Minutes(poll)        
        }
    }
}

//************************************************************
// poll
//     Poll API
//
// Signature(s)
//     poll()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def poll() {

	logger("trace", "poll---")
	requestParams = [ uri: state.HQEventURL, ignoreSSLIssues: true]
	logger("debug", "Poll Api: $requestParams")
	asynchttpGet("pollHandler", requestParams)
	logger("trace", "---End poll")
}

//************************************************************
// pollHandler
//     Handle polled data and do what is needed whit it
//
// Signature(s)
//     pollHandler(resp, data)
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def pollHandler(resp, data) {
	logger("trace", "pollHandler")
	
	if(resp.getStatus() == 200 || resp.getStatus() == 207) {
		logger("debug", "Poll Api Successful")
		
		if (state.apiData == resp.data) {
			logger("debug", "API data has not changed, nothing to do")
			if (state.testMode) {
				logger("debug", "We are in test mode, let's process the JSON file anyway!")
				handleHQEvents()
			}
            currTime = new Date()
            if (currTime > timeToday("23:00")) {
                unschedule(poll)
            }
		} else {
			//Let's save new data to state variable and see what to do
			state.apiData = resp.data
			logger("debug", "New API data, let's see what's new")
			unschedule(poll)
			handleHQEvents()
		}
	} else {
		//Error while poling API, no problem we will poll it again in xx minutes
		logger("warn", "Poll Api error: RESP: " + resp.getStatus() + " - $resp and DATA: $data")
	}
	logger("trace", "---End pollHandler")
}

//************************************************************
// handleHQEvents
//     Handle Hydro Quebec events when they appear in the API
//
// Signature(s)
//     handleHQEvents()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def handleHQEvents() {
	logger("trace", "HandleHQEvents")
	
	response = parseJson(state.apiData)    
	newEventsPush = ""
    
	//Let's go through each event in the JSON file and schedule all new events
	for (eventInfo in response.evenements) {
	
		def currentDateTime = new Date()
								
		if (eventInfo.offre == settings.eventType) {

			eventStartPeriod = toDateTime(eventInfo.dateDebut)
			eventEndPeriod = toDateTime(eventInfo.dateFin)

			//Check if event has ended or not
			if (eventEndPeriod > currentDateTime) {
				logger("debug", "Processing event from $eventStartPeriod to $eventEndPeriod")

				//Add event info to log and notification text
				if (!newEventsPush) {
					newEventsPush = "New HQ events added, from "
				} else {
					newEventsPush = newEventsPush + " & " 
				}
 
				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss")
				Calendar calendar = new GregorianCalendar()
				Date timeVarObj = format.parse(eventInfo.dateDebut)
				calendar.setTime(timeVarObj)
				int integerHour = calendar.get(Calendar.HOUR_OF_DAY)

				//Let's program events 
				if (integerHour < 12) {
					use (TimeCategory) { preEventStartPeriod = eventStartPeriod - preEventMorningMinutes.toInteger().minutes }
						
					if (!timeOfDayIsBetween(preEventStartPeriod, eventStartPeriod, currentDateTime)) {
						schedule(convertISODateTimeToCron(eventInfo.dateDebut, preEventMorningMinutes * -1), setHouseInMorningPreEventMode, [overwrite: false])
					} else {
						log.debug "Pre-Event started, let's go in pre-event mode right away!"
						setHouseInMorningPreEventMode()
					}

					if (!timeOfDayIsBetween(eventStartPeriod, eventEndPeriod, currentDateTime)) {
						schedule(convertISODateTimeToCron(eventInfo.dateDebut, 0), setHouseInMorningEventMode, [overwrite: false])
					} else {
						log.debug "Event started, let's go in pre-event mode right away!"
						setHouseInMorningEventMode()
					}

					schedule(convertISODateTimeToCron(eventInfo.dateFin, 0) , setHouseInMorningNormalMode, [overwrite: false])
					myDeviceNewEvent.speak(eventDetectedTextAM)
				} else {
					use (TimeCategory) { preEventStartPeriod = eventStartPeriod - preEventEveningMinutes.toInteger().minutes }
						
					if (!timeOfDayIsBetween(preEventStartPeriod, eventStartPeriod, currentDateTime)) {
						schedule(convertISODateTimeToCron(eventInfo.dateDebut, preEventEveningMinutes * -1), setHouseInEveningPreEventMode, [overwrite: false])
					} else {
						log.debug "Pre-Event started, let's go in pre-event mode right away!"
						setHouseInEveningPreEventMode()
					}

					if (!timeOfDayIsBetween(eventStartPeriod, eventEndPeriod, currentDateTime)) {
						schedule(convertISODateTimeToCron(eventInfo.dateDebut, 0), setHouseInEveningEventMode, [overwrite: false])
					} else {
						log.debug "Event started, let's go in pre-event mode right away!"
						setHouseInEveningEventMode()
					}

					schedule(convertISODateTimeToCron(eventInfo.dateFin, 0), setHouseInEveningNormalMode, [overwrite: false])
				}
				newEventsPush = newEventsPush + " " + eventStartPeriod + " to " + eventEndPeriod + " "
				myDeviceNewEvent.speak(eventDetectedTextpM)
			}
		}
	}
			
	//Send and log info if required
	if(sendPushMessage && newEventsPush && !state.testMode) {
		sendPushMessage.deviceNotification(newEventsPush)
	}
	if (state.testMode) {
		logger("debug", "No events have been scheduled since the app is in test mode, next line is for DEBUG purposes only!")
	}
	logger("debug", newEventsPush)
	logger("trace", "---End HandleHQEvents")
}

//************************************************************
// convertISODateTimeToCron
//     Converts ISO time to a CRON expression adding minutes
//		to subtract minutes, add a negative number
//
// Signature(s)
//     string = convertISODateTimeToCron(string timeVar, string minutesToAdd)
//
// Parameters
//     timeVar : ISO formatted date
//     minutesToAdd : Minutes to add or subtract
//
// Returns
//     CRON formatted string
//
//************************************************************
def convertISODateTimeToCron(timeVar, minutesToAdd = 0) {
	logger("trace", "convertISODateTimeToCron---")
	
	SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss")
	Calendar calendar = new GregorianCalendar()
	Date timeVarObj = format.parse(timeVar)
	calendar.setTime(timeVarObj)
	calendar.add(Calendar.MINUTE, (minutesToAdd.toInteger()) )
	timeVarObj = calendar.getTime()
	String second = calendar.get(Calendar.SECOND).toString().padLeft(2, '0')
	String hour = calendar.get(Calendar.HOUR_OF_DAY).toString().padLeft(2, '0')
	String minute = calendar.get(Calendar.MINUTE).toString().padLeft(2, '0')
	String day = calendar.get(Calendar.DAY_OF_MONTH).toString().padLeft(2, '0')
	String month = (calendar.get(Calendar.MONTH) + 1).toString().padLeft(2, '0')
	String year = calendar.get(Calendar.YEAR)
	String cronExp = "${second} ${minute} ${hour} ${day} ${month} ? ${year}"
	
	logger("trace", "---end convertISODateTimeToCron")
	return cronExp
}

//************************************************************
// setHouseInMorningPreEventMode
//     Set the different thermostats BEFORE morning mode
//
// Signature(s)
//     setHouseInMorningPreEventMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInMorningPreEventMode() {
    logger("trace", "setHouseInMorningPreEventMode")

	if (eventMorningDisableSwitch || preEventMorningMinutes == 1) {
		logger("warn", "Morning pre-event disabled, skipping this event!")
        exit
    }

	state.currentMode = "MorningPreEvent"
	
	if (eventStateSwitch) {
		eventStateSwitch.on()
	}

	if ((sendPushMessage) && (startMorningPreEventPush)) {
		logger("trace", "Push Message: Morning pre-event fired!")
		sendPushMessage.deviceNotification("HQ Morning pre-event has started!")
	}

	def prePreviousSettings = [:]
	    
	for(thermostat in preEventMorningThermostats) {
		prePreviousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
		newSetpoint = thermostat.currentValue("heatingSetpoint") + preEventMorningDegrees.toInteger()
		thermostat.setHeatingSetpoint(newSetpoint)
		logger("debug", "$thermostat heating setpoint set to $newSetpoint")
	}

	state.prePreviousSettings = prePreviousSettings

	app.updateLabel("$state.name <span style='color:green'>Morning pre-event in progress</span>")

}

//************************************************************
// setHouseBeforeEvening
//     Set the different thermostats BEFORE evening mode
//
// Signature(s)
//     setHouseBeforeEvening()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseBeforeEvening() {
    logger("trace", "setHouseBeforeEvening")

	if (eventBeforeEveningDisableSwitch || preEventEveningMinutes == 1) {
        exit
    }
	
	state.currentMode = "EveningPreEvent"
	
	if (eventStateSwitch) {
		eventStateSwitch.on()
	}
	
	if ((sendPushMessage) && (startMorningPreEventPush)) {
		logger("trace", "Push Message: Morning pre-event fired!")
		sendPushMessage.deviceNotification("HQ Morning pre-event has started!")
	}

	def prePreviousSettings = [:]

	for(thermostat in preEventEveningThermostats) {
		prePreviousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
		newSetpoint = thermostat.currentValue("heatingSetpoint") + preEventEveningDegrees.toInteger()
		thermostat.setHeatingSetpoint(newSetpoint)
		logger("debug", "$thermostat heating setpoint set to $newSetpoint")
	}

	state.prePreviousSettings = prePreviousSettings

	app.updateLabel("$state.name <span style='color:green'>Evening pre-event in progress</span>")
}

//************************************************************
// setHouseInMorningEventMode
//     Set the different outlets, thermostats, etc for morning mode
//
// Signature(s)
//     setHouseInMorningEventMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInMorningEventMode() {
    logger("trace", "setHouseInMorningEventMode")
 
    if (eventMorningDisableSwitch) {
        logger("warn", "Morning event disable activated, skipping this event!  ${eventMorningDisableSwitch}")
        exit
    }
	if (state.currentMode == "MorningPreEvent") {

		for(thermostat in preEventMorningThermostats) {
			def thermostatTemp = state.prePreviousSettings.find{ it.key == "$thermostat" }?.value
			if (thermostatTemp) {
				thermostat.setHeatingSetpoint(thermostatTemp)
				logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
			}
		}

		state.remove("prePreviousSettings")

	}

    state.currentMode = "MorningEvent"
    if (morningEventStateSwitch)
        morningEventStateSwitch.on()
    
    myDeviceMorning.speak(morningBeforeText)
    
    if(sendPushMessage && startMorningEventPush) {
        sendPushMessage.deviceNotification("Morning event fired!")
    }
    
    def previousSettings = [:]
    
    for(eventSwitch in eventMorningSwitches) {
        previousSettings.put("$eventSwitch",eventSwitch.currentValue("switch"))
        eventSwitch.off()
        pauseExecution(1000)
    }

    for(thermostat in eventMorningThermostatsOff) {
        previousSettings.put("$thermostat",thermostat.currentValue("thermostatMode"))
        if (thermostat.currentValue("thermostatMode") == "off") {      
            logger("debug", "$thermostat already off")
        } else {
            thermostat.setThermostatMode("off")
            pauseExecution(1000)
            logger("debug", "$thermostat turned off")
        }
    }
    
    for(thermostat in eventMorningThermostats) {
		previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
		newSetpoint = thermostat.currentValue("heatingSetpoint") - eventMorningDegrees.toInteger()
		thermostat.setHeatingSetpoint(newSetpoint)
		logger("debug", "$thermostat heating setpoint set to $newSetpoint")
        pauseExecution(1000)
    }
    
    state.previousSettings = previousSettings

    app.updateLabel("Hydro Quebec Dynamic Pricing <span style='color:green'>Morning Event in progress</span>")

}


//************************************************************
// setHouseInEveningEventMode
//     Set the different outlets, thermostats, etc for evening mode
//
// Signature(s)
//     setHouseInEveningEventMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInEveningEventMode() {
    logger("trace", "setHouseInEveningEventMode")

    if (eventEveningDisableSwitch) {
        logger("warn", "Evening event disable activated, skipping this event!  ${eventEveningDisableSwitch}")
        exit
    }
	if (state.currentMode == "EveningPreEvent") {

		for(thermostat in preEventEveningThermostats) {
			def thermostatTemp = state.prePreviousSettings.find{ it.key == "$thermostat" }?.value
			if (thermostatTemp) {
				thermostat.setHeatingSetpoint(thermostatTemp)
				logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
			}
		}

		state.remove("prePreviousSettings")

	}

    state.currentMode = "EveningEvent"
    if (eveningEventStateSwitch)
        eveningEventStateSwitch.on()
    
    myDeviceEvening.speak(eveningBeforeText)
    
    if(sendPushMessage && startEveningEventPush) {
        sendPushMessage.deviceNotification("Evening event fired!")
    }
    
    def previousSettings = [:]
    
    for(eventSwitch in eventEveningSwitches) {
        previousSettings.put("$eventSwitch",eventSwitch.currentValue("switch"))
        eventSwitch.off()
        pauseExecution(1000)
    }

    for(thermostat in eventEveningThermostatsOff) {
        previousSettings.put("$thermostat",thermostat.currentValue("thermostatMode"))
        if (thermostat.currentValue("thermostatMode") == "off") {      
            logger("debug", "$thermostat already off")
        } else {
            thermostat.setThermostatMode("off")
            pauseExecution(1000)
            logger("debug", "$thermostat turned off")
        }
    }
    
    for(thermostat in eventEveningThermostats) {
		previousSettings.put("$thermostat",thermostat.currentValue("heatingSetpoint"))
		newSetpoint = thermostat.currentValue("heatingSetpoint") - eventEveningDegrees.toInteger()
		thermostat.setHeatingSetpoint(newSetpoint)
		logger("debug", "$thermostat heating setpoint set to $newSetpoint")
        pauseExecution(1000)
    }
   
    state.previousSettings = previousSettings

    app.updateLabel("Hydro Quebec Dynamic Pricing <span style='color:green'>Evening Event in progress</span>")

}

//************************************************************
// setHouseInMorningNormalMode
//     Set the different outlets, thermostats, etc for normal mode
//
// Signature(s)
//     setHouseInMorningNormalMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInMorningNormalMode() {
    logger("trace", "setHouseInMorningNormalMode")
    
    if (eventMorningDisableSwitch) {
        exit
    }

    state.currentMode = "Normal"
	
    if (morningEventStateSwitch)
        morningEventStateSwitch.off()
    
	def currDate = new SimpleDateFormat("yyyy-MM-dd")    
    def tomorrowSchedule = false
    //Let's check if there is an event schedule for tomorrow
	scheduledJobs.each { jobName, jobDetails ->
		if (jobName == "setHouseInMorningEventMode" && formatDateOnly(jobDetails.nextRun) > currDate)
        	tomorrowSchedule == true
	}
    if (tomorrowSchedule == false) 
        tomorrowMorningEventStateSwitch.off()
    
    myDeviceMorning.speak(morningAfterText)

    if(sendPushMessage && endMorningEventPush) {
        sendPushMessage.deviceNotification("Back to normal!")
    }
    
    for(eventSwitch in eventMorningSwitches) {
        def switchState = state.previousSettings.find{ it.key == "$eventSwitch" }?.value
        if(switchState && switchState == "on") {
            logger("debug", "$eventSwitch turned $switchState")
            eventSwitch.on()
            pauseExecution(1000)
        } else {
            logger("debug", "$eventSwitch not changed")
        }
    }

    for(thermostat in eventMorningThermostatsOff) {
        def thermostatMode = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatMode) {
            thermostat.setThermostatMode("$thermostatMode")
            pauseExecution(1000)
            logger("debug", "$thermostat mode set to $thermostatMode")
        }
    }

    for(thermostat in eventMorningThermostats) {
        def thermostatTemp = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatTemp) {
            thermostat.setHeatingSetpoint(thermostatTemp)
            logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
            pauseExecution(2000)
        }
    }
    
    state.remove("previousSettings")
    app.updateLabel("Hydro Quebec Dynamic Pricing")
    
}


//************************************************************
// setHouseInEveningNormalMode
//     Set the different outlets, thermostats, etc for normal mode
//
// Signature(s)
//     setHouseInEveningNormalMode()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def setHouseInEveningNormalMode() {
    logger("trace", "setHouseInEveningNormalMode")

    if (eventEveningDisableSwitch) {
        exit
    }

    state.currentMode = "Normal"
    if (eveningEventStateSwitch)
        eveningEventStateSwitch.off()
    
	def currDate = new SimpleDateFormat("yyyy-MM-dd")    
    def tomorrowSchedule = false
    //Let's check if there is an event schedule for tomorrow
	scheduledJobs.each { jobName, jobDetails ->
		if (jobName == "setHouseInEveningEventMode" && formatDateOnly(jobDetails.nextRun) > currDate)
        	tomorrowSchedule == true
	}
    if (tomorrowSchedule == false) 
        tomorrowEveningEventStateSwitch.off()
    
    myDeviceEvening.speak(eveningAfterText)

    if(sendPushMessage && endEveningEventPush) {
        sendPushMessage.deviceNotification("Back to normal!")
    }
    
    for(eventSwitch in eventEveningSwitches) {
        def switchState = state.previousSettings.find{ it.key == "$eventSwitch" }?.value
        if(switchState && switchState == "on") {
            logger("debug", "$eventSwitch turned $switchState")
            eventSwitch.on()
            pauseExecution(1000)
        } else {
            logger("debug", "$eventSwitch not changed")
        }
    }

    for(thermostat in eventEveningThermostatsOff) {
        def thermostatMode = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatMode) {
            thermostat.setThermostatMode("$thermostatMode")
            pauseExecution(1000)
            logger("debug", "$thermostat mode set to $thermostatMode")
        }
    }

    for(thermostat in eventEveningThermostats) {
        def thermostatTemp = state.previousSettings.find{ it.key == "$thermostat" }?.value
        if (thermostatTemp) {
            thermostat.setHeatingSetpoint(thermostatTemp)
            logger("debug", "$thermostat heating setpoint set to $thermostatTemp")
            pauseExecution(2000)
        }
    }
    
    state.remove("previousSettings")
    app.updateLabel("Hydro Quebec Dynamic Pricing")
    
}

//************************************************************
// logger
//     Wrapper function for all logging with level control via preferences
//
// Signature(s)
//     logger(String level, String msg)
//
// Parameters
//     level : Error level string
//     msg : Message to log
//
// Returns
//     None
//
//************************************************************
def logger(level, msg) {

	switch(level) {
		case "error":
			if (settings.logLevel in ["1", "2", "3", "4", "5"]) log.error msg
			break

		case "warn":
			if (settings.logLevel in ["2", "3", "4", "5"]) log.warn msg
			break

		case "info":
			if (settings.logLevel in ["3", "4", "5"]) log.info msg
			break

		case "debug":
			if (settings.logLevel in ["4", "5"]) log.debug msg
			break

		case "trace":
			if (settings.logLevel in ["5"]) log.trace msg
			break

		default:
			log.debug msg
			break
	}
}


//************************************************************
// logsDropLevel
//     Turn down logLevel to 3 in this app/device and log the change
//
// Signature(s)
//     logsDropLevel()
//
// Parameters
//     None
//
// Returns
//     None
//
//************************************************************
def logsDropLevel() {
    app.updateSetting("logLevel", [type: "enum", value: "3"])
	logger("warn","Logging level set to 3")
}


//************************************************************
// getDisplayUnits
//     Get the diplay units
// Signature(s)
//     getDisplayUnits()
// Parameters
//     None
// Returns
//     Formated Units String
//************************************************************
def getDisplayUnits() {
	if (getTemperatureScale() == "C") {
		return "°C"
	} else {
		return "°F"
	}
}


//************************************************************
// getFormat
//     Get the fornat for headers
// Signature(s)
//     getFormat(String type, String myText)
// Parameters
//     type: format
//     myTest: Text to diplay
// Returns
//     None
//************************************************************
def getFormat(type, myText="") {			// Modified from @Stephack Code   
	if(type == "header-green") return "<div style='color:#ffffff;font-weight: bold;background-color:#81BC00;border: 1px solid;box-shadow: 2px 3px #A9A9A9'>${myText}</div>"
    if(type == "line") return "<hr style='background-color:#1A77C9; height: 1px; border: 0;'>"
    if(type == "title") return "<h2 style='color:#1A77C9;font-weight: bold'>${myText}</h2>"
}

//************************************************************
// getImage
//     Get the image for headers
// Signature(s)
//     getImage(String type)
// Parameters
//     type: Image
// Returns
//     None
//************************************************************
def getImage(type) {					// Modified from @Stephack Code
    def loc = "<img src=https://raw.githubusercontent.com/jbilodea/HydroQuebec/main/Images/"
    if(type == "Blank") return "${loc}blank.png height=40 width=5}>"
    if(type == "checkMarkGreen") return "${loc}checkMarkGreen2.png height=30 width=30>"
    if(type == "optionsGreen") return "${loc}options-green.png height=30 width=30>"
    if(type == "optionsRed") return "${loc}options-red.png height=30 width=30>"
    if(type == "instructions") return "${loc}instructions.png height=30 width=30>"
    if(type == "logo") return "${loc}logo.png height=60>"
}

//************************************************************
// appButtonHandler
//     Handle menu button events 
// Signature(s)
//     appButtonHandler(string buttonName)
// Parameters
//     None
// Returns
//     None
//************************************************************
void appButtonHandler(String btn) {
   switch (btn) {
      case 'btnOne':
         logger("info", "Button one pressed")
         setHouseInMorningEventMode()
         break
      case 'btnTwo':
         logger("info", "Button two pressed")
         setHouseInMorningNormalMode()
         break
      case 'btnThree':
         logger("info", "Button three pressed")
         poll()
         break
      default:
         logger("warn","Button not handled")
   }
}


//************************************************************
// *** Hiden menu handlers ***
// Parameters
//     None
// Returns
//     Boolean
//************************************************************
private hideEventTypeSection() {(eventType) ? true : false}
private hideAdvancedSection() {(isInfo || isDebug || isTrace || ifLevel) ? false : true}
private hideLogSection() {(logLevel || logDropLevelTime) ? false : true}
private hideNotificationSection() {(sendPushMessage || startMorningEventPush || endMorningEventPush || startEveningEventPush || endEveningEventPush || newEventsPush || restartEventRecoveryPush) ? false : true}
